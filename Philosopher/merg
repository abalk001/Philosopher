/* header */

#ifndef PHILO_H
#define PHILO_H


# include <unistd.h>
# include <stdlib.h>
# include <stdio.h> // write, usleep
# include <stdbool.h>
# include <pthread.h> // mutex and threads
# include <sys/time.h>
# include <limits.h>

/* OP CODE FOR MUTEX */

typedef enum e_opcode
{
	LOCK,
	UNLOCK,
	INIT,
	DESTROY,
	CREATE,
	JOIN,
	DETACH,

}	t_opcode;

typedef enum e_time
{
	SECOND,
	MS,
	US,
}	t_time_code;

typedef enum e_status
{
	EATING,
	SLEEPING,
	THINKING,
	TAKE_FIRST_FORK,
	TAKE_SECOND_FORK,
	DIED,
}		t_philo_status;

/* STRUCT THAT SHIT  */
typedef pthread_mutex_t t_mtx;
typedef struct s_table t_table;

typedef struct s_fork
{
	t_mtx	fork;
	int		fork_id;
}	t_fork;


//./ philo 5 800 200 200 [5]  time to die time to sleep time_fucking_dieeee
typedef struct s_philo
{
	int			id;
	long		meals_counters;
	bool		full;
	long		last_meal_time;  // time passed from last meal
	t_fork		*first_fork;
	t_fork		*second_fork; 
	pthread_t	thread_id; // a philo is a thread to societyyyy 
	t_mtx		philo_mutex; // use for moni
	t_table		*table;
}	t_philo;


struct s_table   //shared data
{
	long	philo_nbr;
	long	t_die;
	long	t_eat;
	long	t_sleep;
	long	m_meals;// [4] Flag if -1 
	long	str_sim;
	bool	end_sim; // when a philo die or when all philo are full
	bool	all_threads_ready; //sych philos
	t_mtx	table_mutex;
	t_mtx	write_mutex;
	t_fork	*fork; // array to forks 
	t_philo	*philos;
};
void	parse_input(t_table *table, char **av);
void	error_exit(const char *error);
bool	is_space(char c);
bool	is_digit(char c);
/* Data init */
void	data_init(t_table *table);
void	*safe_malloc(size_t bytes);
void	safe_thread_handle(pthread_t *thread, void *(*foo) (void *),
			void *data, t_opcode opcode);
void	safe_mutex_handle(t_mtx *mutex, t_opcode opcode);
/* set_stuff*/
bool	sim_finish(t_table *table);
long	get_long(t_mtx *mutex, long *value);
void	set_long(t_mtx *mutex, long *dest, long value);
bool	get_bool(t_mtx *mutex, bool *value);
void	set_bool(t_mtx *mutex, bool *dest, bool value);
/* Dinner */
void	dinner_start(t_table *table);
void	*dinner_simulation(void *data);
void	wait_all_threads(t_table *table);
/* time */
long	get_time(t_time_code time_code);
void	precise_unsleep(long usec, t_table *table);
/* monitoring */
void	monitoring(t_philo_status status, t_philo *philo);
# endif 



/* Main.c */

#include "philo.h"
//./ philo 5 800 200 200 [5]

int main(int ac, char **av)
{
	t_table  table;
	if(5 == ac || 6 == ac)
	{
		parse_input(&table, av); 
		data_init(&table);
		dinner_start(&table); // Still

		//4) No leaks -> all philos are full or 1 philo is dead
		//clean(&table); // TDL
		printf("heresup\n");
	}
	else
		error_exit("Wrong input\n");
	return (EXIT_SUCCESS);
}

/*pasring*/
#include "philo.h"


// /philo av[1] ..... av[5]
// no max reached and timestamps > 60ms (1s)

static const char	*valid_input(const char *str)
{
	int			len;
	const char	*nbr;

	len = 0;
	while (is_space(*str))
		++str;
	if (*str == '+')
		++str;
	else if (*str == '-')
		error_exit("check input");
	if (!is_digit(*str))
		error_exit("check_output");
	nbr = str; // the actual nbr
	while (is_digit(*str++))
		++len;
	if (len > 10) // recheck that 
		error_exit("too long");
	return (nbr);
}

static long	ft_atoi(const char *str)
{
	long	num;

	num = 0;
	str = valid_input(str); // check if it's a number ot not 
	while (is_digit(*str))
		num = (num * 10) + ( *str++ - 48);
	if (num > INT_MAX)
		error_exit("too big");
	return (num);
}

void	parse_input(t_table *table, char **av)
{
	table->philo_nbr = ft_atoi(av[1]);
	printf("%li\n", table->philo_nbr);
	table->t_die = ft_atoi(av[2]);
	table->t_eat = ft_atoi(av[3]);
	table->t_sleep = ft_atoi(av[4]);
	if (av[5])
		table->m_meals = ft_atoi(av[5]);
	else
		table->m_meals = -1;
}

/* DATA INIT */

#include "philo.h"


static void	assign_fork(t_philo *philo, t_fork *forks, int philo_position)
{
	int	philo_nbr;

	philo_nbr = philo->table->philo_nbr;
	philo->second_fork = &forks[philo_position];
	philo->first_fork = &forks[(philo_position + 1) % philo_nbr];
	if (philo_nbr % 2 == 0)
	{
		philo->first_fork = &forks[philo_position];
		philo->second_fork = &forks[(philo_position + 1) % philo_nbr];
	}
}

static void	philo_init(t_table *table)
{
	int		i;
	t_philo	*philo;

	i = -1;
	while (++i < table->philo_nbr)
	{
		philo = table->philos + i;
		philo->id = i + 1;
		philo->full = false;
		philo->meals_counters = 0;
		philo->table = table;
		safe_mutex_handle(&philo->philo_mutex, INIT);
		assign_fork(philo, table->fork, i);
	}
}

void	data_init(t_table *table)
{
	int	i;

	i = -1;
	table->end_sim = false;
	table->all_threads_ready = false;
	safe_mutex_handle(&table->table_mutex, INIT);
	safe_mutex_handle(&table->write_mutex, INIT);
	table->philos = safe_malloc(sizeof(t_philo) * table->philo_nbr);
	table->fork = safe_malloc(sizeof(t_fork) * table->philo_nbr);
	while (++i < table->philo_nbr)
	{
		safe_mutex_handle(&table->fork[i].fork, INIT);
		table->fork[i].fork_id = i;
	}
	philo_init(table);
}

/* dinner */ 

void	*long_philo(void *data)
{
	t_philo	*philo;

	philo = (t_philo *)data;
	wait_all_threads(philo->table);
	set_long(&philo->philo_mutex, &philo->last_meal_time, get_time(MS));
	increase_long(&philo->table->table_mutex, &philo->table->threads_running_nbr);
	monitoring(TAKE_FIRST_FORK, philo);
	while(!sim_finish(philo->table))
		usleep(200);
	return (NULL);
}





// 0) If no meals return ->0
// 1 ) if onlu one philo -> ad hoc
// 2/ Create all threads, all philos
// 2) Create a monitor thread
// 3) Sync the beggining simulation ( all start in the same time )
static void	thinking(t_philo *philo)
{
	monitoring(THINKING,philo);
}
static void	eat(t_philo *philo)
{
	safe_mutex_handle(&philo->first_fork->fork, LOCK);
	monitoring(TAKE_FIRST_FORK, philo);
	safe_mutex_handle(&philo->second_fork->fork, LOCK);
	monitoring(TAKE_SECOND_FORK, philo);
	set_long(&philo->philo_mutex, &philo->last_meal_time, get_time(MS));
	philo->meals_counters++;
	monitoring(EATING, philo);
	precise_unsleep(philo->table->t_eat, philo->table);
	if (philo->table->m_meals > 0 && philo->meals_counters == philo->table->m_meals)
		set_bool(&philo->philo_mutex, &philo->full, true);
	safe_mutex_handle(&philo->first_fork->fork, UNLOCK);
	safe_mutex_handle(&philo->second_fork->fork, UNLOCK);
}
void	*dinner_simulation(void *data)
{
	t_philo	*philo;

	philo = (t_philo *)data;
	wait_all_threads(philo->table);
	set_long(&philo->philo_mutex, &philo->last_meal_time, get_time(MS));
	increase_long(&philo->table->table_mutex, &philo->table->threads_running_nbr);
	while(!sim_finish(philo->table))
	{
		if (philo->full) // recheck this
			break;
		eat(philo);
		monitoring(SLEEPING, philo);
		precise_unsleep(philo->table->t_sleep, philo->table);
		thinking(philo);
	}
	return(NULL);
}

void dinner_start(t_table *table)
{
	int i;

	i = -1;
	if (0 == table->m_meals)
		return;
	else if (1 == table->philo_nbr)
		safe_thread_handle(&table->philos[0].thread_id, long_philo, &table->philos[0], CREATE);
	else
	{
		while (++i < table->philo_nbr)
			safe_thread_handle(&table->philos[i].thread_id, dinner_simulation,
				&table->philos[i], CREATE);

	}
	// now all threads are ready !
	safe_thread_handle(&table->monitor_thread, monitor_dinner,table, CREATE);
	table->str_sim = get_time(MS);
	set_bool(&table->table_mutex,  &table->all_threads_ready, true);

	i = -1;
	while (++i < table->philo_nbr)
		safe_thread_handle(&table->philos[i].thread_id, NULL, NULL, JOIN);
	set_bool(&table->table_mutex, &table->end_sim, true);
	safe_thread_handle(&table->monitor_thread, NULL, NULL, JOIN);

}
/* FCT */ 

#include "philo.h"
#include <errno.h>

/*MUTEX
 * INIT
 * DESTROY
 * LOCK
 * UNLOCK
*/

static void	handle_mutex_error(int status, t_opcode opcode)
{
	if (status == 0)
		return ;
	if (EINVAL == status && (LOCK == opcode || DESTROY == opcode
			|| UNLOCK == opcode))
		error_exit("The value specified by mutex is invalid");
	else if (EINVAL == status && INIT == opcode)
		error_exit("The value specified by attr is invalid.");
	else if (EDEADLK == status)
		error_exit("A deadlock would occur if the"
			" thread blocked waiting for mutex.");
	else if (EPERM == status)
		error_exit("The current thread does "
			"not hold a lock on mutex.");
	else if (ENOMEM == status)
		error_exit("The process cannot allocate "
			"enough memory to create another mutex.");
	else if (EBUSY == status)
		error_exit("Mutex is locked");
}

void	safe_mutex_handle(t_mtx *mutex, t_opcode opcode)
{
	if (LOCK == opcode)
		handle_mutex_error(pthread_mutex_lock(mutex), opcode);
	else if (UNLOCK == opcode)
		handle_mutex_error(pthread_mutex_unlock(mutex), opcode);
	else if (INIT == opcode)
		handle_mutex_error(pthread_mutex_init(mutex, NULL), opcode);
	else if (DESTROY == opcode)
		handle_mutex_error(pthread_mutex_destroy(mutex), opcode);
	else
		error_exit("Wrong opcode for mutex handle");
}
/* THREADS */

static void	handle_thread_error(int status, t_opcode opcode)
{
	if (0 == status)
		return ;
	if (EAGAIN == status)
		error_exit("No resources to create another thread");
	else if (EPERM == status)
		error_exit("The caller does not have appropriate permission\n");
	else if (EINVAL == status && CREATE == opcode)
		error_exit("The value specified by attr is invalid.");
	else if (EINVAL == status && (JOIN == opcode || DETACH == opcode))
		error_exit("The value specified by thread is not joinable\n");
	else if (ESRCH == status)
		error_exit("No thread could be found corresponding to "
			"that specified by the given thread ID, thread.");
	else if (EDEADLK == status)
		error_exit("A deadlock was detected or the value of "
			"thread specifies the calling thread.");
}

void	safe_thread_handle(pthread_t *thread, void *(*foo) (void *),
			void *data, t_opcode opcode)
{
	if (CREATE == opcode)
		handle_thread_error(pthread_create(thread, NULL, foo, data), opcode);
	else if (JOIN == opcode)
		handle_thread_error(pthread_join(*thread, NULL), opcode);
	else if (DETACH == opcode)
		handle_thread_error(pthread_detach (*thread), opcode);
	else
		error_exit("Wrong opcode for thread_handle: "
			"use <CREATE> <JOIN> <DETACH>");
}


static bool	philo_died(t_philo *philo)
{
	long elapsed;
	long t_die;

	if (get_bool(&philo->philo_mutex, &philo->full))
		return (false);
	elapsed = get_time(MS) - get_long(&philo->philo_mutex, &philo->last_meal_time);
	t_die = philo->table->t_die / 1e3 ; // convert here

	if(elapsed > t_die)
		return (true);
	return (false);
}

void	monitoring(t_philo_status status, t_philo *philo)
{
	long elapsed;

	if (philo->full)
		return;
	elapsed = get_time(MS) - philo->table->str_sim;
	safe_mutex_handle(&philo->table->write_mutex, LOCK);
	if ((TAKE_FIRST_FORK == status || TAKE_SECOND_FORK == status) && !sim_finish(philo->table))
		printf("%-5ld %d has taken a fork\n", elapsed, philo->id);
	else if (EATING == status && !sim_finish(philo->table))
		printf("%-5ld %d is eating\n", elapsed, philo->id);
	else if (SLEEPING == status && !sim_finish(philo->table))
		printf("%-5ld %d is sleeping\n", elapsed, philo->id);
	else if (THINKING == status && !sim_finish(philo->table))
		printf("%-5ld %d is thinking\n", elapsed, philo->id);
	else if (DIED == status)
		printf("%-5ld %d died\n", elapsed, philo->id);
	safe_mutex_handle(&philo->table->write_mutex, UNLOCK);
}

void	*monitor_dinner(void *data)
{
	t_table *table;
	int i;

	table = (t_table *)data;
	while(!all_threads_running(&table->table_mutex, &table->threads_running_nbr, table->philo_nbr))
		;
	while (!sim_finish(table))
	{
		i = -1;
		while(++i < table->philo_nbr && !sim_finish(table))
		{
			if(philo_died(table->philos + i))
			{
				set_bool(&table->table_mutex, &table->end_sim, true);
				monitoring(DIED, table->philos + i);
			}
		}
	}
	return(NULL);
}

void	set_bool(t_mtx *mutex, bool *dest, bool value)
{
	safe_mutex_handle(mutex, LOCK);
	*dest = value;
	safe_mutex_handle(mutex, UNLOCK);
}

bool	get_bool(t_mtx *mutex, bool *value)
{
	bool	ret;

	safe_mutex_handle(mutex, LOCK);
	ret = *value;
	safe_mutex_handle(mutex, UNLOCK);
	return (ret);
}

void	set_long(t_mtx *mutex, long *dest, long value)
{
	safe_mutex_handle(mutex, LOCK);
	*dest = value;
	safe_mutex_handle(mutex, UNLOCK);
}

long	get_long(t_mtx *mutex, long *value)
{
	long	ret;

	safe_mutex_handle(mutex, LOCK);
	ret = *value;
	safe_mutex_handle(mutex, UNLOCK);
	return (ret);
}

bool	sim_finish(t_table *table)
{
	return (get_bool(&table->table_mutex, &table->end_sim));
}
void	wait_all_threads(t_table *table)
{
	while(!get_bool(&table->table_mutex,&table->all_threads_ready))
	;
}

bool	all_threads_running(t_mtx *mtx, long *threads, long philo_nbr)
{
	bool		ret;

	ret = false;
	safe_mutex_handle(mtx, LOCK);
	if (*threads == philo_nbr)
		ret = true;
	safe_mutex_handle(mtx, UNLOCK);
	return (ret);
}

void increase_long(t_mtx *mtx, long *value)
{
	safe_mutex_handle(mtx, LOCK);
	(*value)++;
	safe_mutex_handle(mtx, UNLOCK);
}

long	get_time(t_time_code time_code)
{
	struct timeval tv;
	
	if(gettimeofday(&tv, NULL))
		error_exit("Gettime failed miserably like your life");
	if (SECOND == time_code)
		return (tv.tv_sec + (tv.tv_usec/ 1e6));
	else if (MS == time_code)
		return ((tv.tv_sec * 1e3) + (tv.tv_usec / 1e3));
	else if (US == time_code)
		return ((tv.tv_sec * 1e6) + tv.tv_usec);
	else
		error_exit("wrong input");
	return(42);
}

void	precise_unsleep(long usec, t_table *table)
{
	long	start;
	long	elapsed;
	long	rem;

	start = get_time(MS);
	while(get_time(MS) - start < usec)
	{
		if (sim_finish(table))
			break;
		elapsed = get_time(MS) - start;
		rem = usec - elapsed;
		if (rem > 1e3)
			usleep(rem / 2); 
		else
		{
			while(get_time(MS) - start < usec )	
				;
		}
	}
}

void	error_exit(const char *error)
{
	printf("%s\n", error); /* Recheck that */
	exit(EXIT_FAILURE);
}

bool	is_space(char c)
{
	return ((c >= 9 && c <= 13) || c == 33);
}

bool	is_digit(char c)
{
	return ((c >= '0') && c <= '9' );
}

void	*safe_malloc(size_t bytes)
{
	void	*ret;

	ret = malloc(bytes);
	if (NULL == ret)
		error_exit("Error with the malloc");
	return (ret);
}
